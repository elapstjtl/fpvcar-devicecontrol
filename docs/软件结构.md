好的，这是一个非常实际的工程问题。`fpvcar-devicecontrol` 的核心职责是：**启动、监听IPC、解析JSON、调用C++库、返回JSON响应**。

这里有一套清晰的、可扩展的 C++ 项目结构规划，它遵循了“关注点分离” (Separation of Concerns) 的原则。

### 核心思想

1.  **`main` 只负责启动和关闭**：`main.cpp` 的职责是初始化服务、处理 `Ctrl+C` (SIGINT) 信号，然后优雅地关闭服务。
2.  **`DeviceControlService` (核心服务类)**：这是“粘合剂”。它**拥有** `FpvCarController` 实例和 `IpcServer` 实例。
3.  **`IpcServer` (IPC 服务)**：专门负责监听 Unix Domain Socket (UDS) 或 gRPC。它**不关心**消息内容，只负责接收请求字符串，并等待一个响应字符串。
4.  **`RequestHandler` (请求处理器)**：专门负责**解析 JSON**，调用 `FpvCarController` 的正确方法，并**生成 JSON 响应**。

-----

### 推荐的目录结构

```
fpvcar-devicecontrol/
├── include/
│   └── fpvcar/
│       └── device_control/
│           ├── device_control_service.hpp   // 核心服务类 (粘合剂)
│           ├── ipc_server.hpp               // IPC 服务器类 (例如 UDS)
│           ├── request_handler.hpp          // JSON 请求处理器
│           └── config.hpp                   // 配置加载 (如 socket 路径, 引脚定义)
│
├── src/
│   ├── main.cpp                       // 主程序入口 (启动/关闭)
│   ├── device_control_service.cpp
│   ├── ipc_server.cpp
│   ├── request_handler.cpp
│   └── config.cpp
│
├── CMakeLists.txt                     // CMake 配置文件
│
└── config/
    └── default_config.json            // 运行时的配置文件
```

-----

### 各文件职责详解

#### `include/fpvcar/device_control/`

这是暴露给内部的头文件。

  * **`config.hpp`**

      * **职责**：定义 `AppConfig` 结构体，并声明一个加载配置的函数。
      * **内容**：
        ```cpp
        #pragma once
        #include <string>
        #include "fpvcar_motor/config.hpp" // 引入 FpvCarPinConfig

        namespace fpvcar::device_control::config {
            struct AppConfig {
                fpvcar::config::FpvCarPinConfig pins;
                std::string ipc_socket_path = "/tmp/fpvcar_control.sock";
                // ... 其他配置
            };

            // 从文件加载配置 (如 JSON 或 TOML)
            AppConfig load_config(const std::string& file_path);
        }
        ```

  * **`request_handler.hpp`**

      * **职责**：定义请求处理器。它持有对 `FpvCarController` 的**引用**。
      * **内容**：
        ```cpp
        #pragma once
        #include <string>
        #include "fpvcar_motor/control/fpvcar_controller.hpp" // 引入 C++ API 库

        namespace fpvcar::device_control {
            class RequestHandler {
            public:
                // 构造时传入 car 实例的引用
                RequestHandler(fpvcar::control::FpvCarController& car);

                // 核心方法：接收 JSON 请求，返回 JSON 响应
                std::string handle_request(const std::string& json_request);

            private:
                fpvcar::control::FpvCarController& m_controller;

                // 辅助函数，用于生成 JSON 响应
                std::string create_success_response(const std::string& message);
                std::string create_error_response(const std::string& code, const std::string& message);
            };
        }
        ```

  * **`ipc_server.hpp`**

      * **职责**：定义 IPC 服务器。这里以 UDS (Unix Domain Socket) 为例。它持有一个**回调函数**，这个回调函数就是 `RequestHandler::handle_request`。
      * **内容**：
        ```cpp
        #pragma once
        #include <string>
        #include <functional>
        #include <atomic>

        namespace fpvcar::device_control {
            // 定义一个回调类型：输入 string (请求), 输出 string (响应)
            using IpcCallback = std::function<std::string(const std::string&)>;

            class IpcServer {
            public:
                IpcServer(const std::string& socket_path, IpcCallback callback);
                ~IpcServer();

                // 启动服务器 (阻塞, 在单独的线程中运行)
                void run();
                
                // 停止服务器
                void stop();

            private:
                std::string m_socket_path;
                IpcCallback m_callback;
                int m_listen_fd = -1;
                std::atomic<bool> m_running{false};
            };
        }
        ```

  * **`device_control_service.hpp`**

      * **职责**：**拥有**所有权。它负责创建和管理 `FpvCarController`、`RequestHandler` 和 `IpcServer` 的生命周期。
      * **内容**：
        ```cpp
        #pragma once
        #include "config.hpp"
        #include "request_handler.hpp"
        #include "ipc_server.hpp"
        #include "fpvcar_motor/control/fpvcar_controller.hpp"
        #include <thread>

        namespace fpvcar::device_control {
            class DeviceControlService {
            public:
                DeviceControlService(const config::AppConfig& config);
                ~DeviceControlService(); // 确保析构时能正确停止服务器

                // 启动服务 (非阻塞)
                void start();
                
                // 停止服务 (等待线程退出)
                void stop();

            private:
                config::AppConfig m_config;
                
                // 注意所有权：Service 拥有这三个核心组件
                fpvcar::control::FpvCarController m_controller;
                RequestHandler m_handler;
                IpcServer m_server;

                std::thread m_server_thread;
            };
        }
        ```

#### `src/`

这里是所有 `.cpp` 实现文件。

  * **`main.cpp`**

      * **职责**：程序入口、信号处理。
      * ```cpp
          #include "fpvcar/device_control/device_control_service.hpp"
          #include "fpvcar/device_control/config.hpp"
          #include <iostream>
          #include <signal.h>
          
          // 全局原子变量，用于捕获 SIGINT (Ctrl+C)
          std::atomic<bool> g_shutdown_request{false};
          
          void signal_handler(int signal) {
              g_shutdown_request = true;
          }

          int main(int argc, char** argv) {
              signal(SIGINT, signal_handler);
              signal(SIGTERM, signal_handler);

              try {
                  // 1. 加载配置
                  auto config = fpvcar::device_control::config::load_config("config/default_config.json");
                  
                  // 2. 初始化服务
                  fpvcar::device_control::DeviceControlService service(config);

                  // 3. 启动服务 (在后台线程运行)
                  service.start();
                  std::cout << "fpvcar-devicecontrol service started. Press Ctrl+C to stop." << std::endl;

                  // 4. 主线程等待关闭信号
                  while (!g_shutdown_request) {
                      std::this_thread::sleep_for(std::chrono::milliseconds(100));
                  }

                  // 5. 收到信号，优雅关闭
                  std::cout << "Shutting down service..." << std::endl;
                  service.stop();
                  std::cout << "Service stopped." << std::endl;

              } catch (const std::exception& e) {
                  std::cerr << "FATAL ERROR: " << e.what() << std::endl;
                  return 1;
              }

              return 0;
          }
        ```

  * **`device_control_service.cpp`**

      * **职责**：实现 `DeviceControlService`。关键在于**构造函数初始化列表**，它定义了依赖关系。
      * ```cpp
          #include "fpvcar/device_control/device_control_service.hpp"
          #include <iostream>

          namespace fpvcar::device_control {

          DeviceControlService::DeviceControlService(const config::AppConfig& config)
              : m_config(config),
                // 1. 首先，创建 Controller (它可能会抛出 gpiod 异常)
                m_controller(
                    fpvcar::config::GPIO_CHIP_NAME, // 假设使用 motor 库的默认值
                    m_config.pins,
                    fpvcar::config::GPIO_CONSUMER_NAME
                ),
                // 2. 然后，创建 Handler，并把 Controller 的引用传给它
                m_handler(m_controller),
                // 3. 最后，创建 Server，并把 Handler 的方法作为回调传给它
                m_server(
                    m_config.ipc_socket_path,
                    // 使用 lambda 绑定 m_handler 的 this 指针
                    [this](const std::string& req) {
                        return m_handler.handle_request(req);
                    }
                )
          {
              std::cout << "DeviceControlService initialized." << std::endl;
          }

          DeviceControlService::~DeviceControlService() {
              stop(); // 确保析构时停止服务
          }

          void DeviceControlService::start() {
              // 在新线程中运行服务器的阻塞循环
              m_server_thread = std::thread([this]() {
                  m_server.run();
              });
          }

          void DeviceControlService::stop() {
              m_server.stop(); // 停止服务器
              if (m_server_thread.joinable()) {
                  m_server_thread.join(); // 等待服务器线程结束
              }
          }

          } // namespace fpvcar::device_control
        ```

  * **`request_handler.cpp`**

      * **职责**：实现 JSON 解析和 `car` 的调用（你上一问的伪代码就放在这里）。
      * 你需要一个 JSON 库，例如 `nlohmann/json`。

  * **`ipc_server.cpp`**

      * **职责**：实现 UDS 的 `socket`, `bind`, `listen`, `accept`, `read`, `write` 循环。`accept` 循环应该检查 `m_running` 标志位以实现优雅退出。

  * **`config.cpp`**

      * **职责**：实现 `load_config`。读取文件（如 `nlohmann/json`），填充 `AppConfig` 结构体。

这个结构将网络（IPC）、逻辑（Handler）和硬件（Controller）清晰地分开了，非常便于维护和单独测试（例如，你可以很容易地写一个测试来“模拟”`handle_request` 的 JSON 输入）。